This approach is correct in concept but will be extremely inefficient with your data size. Let me break it down:
The Problem:
SRCL_OPEN: 1.3M records × 9 coordinates = 11.7M coordinate pairs
ODEF: 18K educational institutions
Cross join creates: 11.7M × 18K = 210 BILLION distance calculations
This will take forever to run and might crash.
Better Approach: Use PROC SQL with Conditional Logic
Since you only need the minimum distance for each coordinate, you can optimize this significantly:
/* Step 1: Create a macro to find closest institution for one coordinate type */
%macro find_closest(coord_type, lat_var, long_var);

proc sql;
    create table closest_&coord_type as
    select 
        a.id,
        b.inst_id as closest_&coord_type._inst,
        min(geodist(a.&lat_var, a.&long_var, b.Latitude, b.Longitude, 'K')) as dist_&coord_type._inst
    from SRCL_OPEN as a
    cross join ODEF as b
    group by a.id;
quit;

%mend;

/* Step 2: Run for all three coordinate types */
%find_closest(brn, brn_lat, brn_long);
%find_closest(trn, trn_lat, trn_long);
%find_closest(res, res_lat, res_long);

/* Step 3: Merge all results back */
proc sql;
    create table final_result as
    select 
        a.*,
        b.closest_brn_inst,
        b.dist_brn_inst,
        c.closest_trn_inst,
        c.dist_trn_inst,
        d.closest_res_inst,
        d.dist_res_inst
    from SRCL_OPEN as a
    left join closest_brn as b on a.id = b.id
    left join closest_trn as c on a.id = c.id
    left join closest_res as d on a.id = d.id;
quit;
Even Better: Use INDEX for Performance
/* Create indexes first */
proc sql;
    create index id on SRCL_OPEN(id);
    create index inst_id on ODEF(inst_id);
quit;
Why This is Better:
✅ Still does the cross join but uses min() aggregation efficiently
✅ Processes one coordinate type at a time (manageable chunks)
✅ SAS can optimize the min() operation
✅ Final merge is fast with indexes
Expected Runtime:
Original approach: Hours/days or crash
Optimized approach: 30-90 minutes depending on your hardware
Alternative: Sample and Test First
/* Test with 1000 records first */
proc sql outobs=1000;
    create table test_sample as
    select * from SRCL_OPEN;
quit;
Run your logic on test_sample first to verify it works, then scale up.
Does this make sense? Want me to refine this further based on your specific needs?