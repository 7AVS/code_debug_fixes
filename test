"""
VVD Date Range Analysis
Check date ranges per campaign to plan hybrid aggregation strategy
"""

from pyspark.sql import SparkSession
from pyspark.sql import functions as F

# Initialize Spark
spark = SparkSession.builder \
    .appName("VVD Date Range Analysis") \
    .getOrCreate()

# Load tactic
tactic = spark.read.parquet("/user/427966379/tactic.parquet")

print("="*80)
print("VVD DATE RANGE ANALYSIS - FOR HYBRID AGGREGATION PLANNING")
print("="*80)

# For each campaign, show date distribution
for mne in ["VCN", "VDA", "VDT", "VUI", "VUT", "VAW"]:
    print(f"\n{'='*80}")
    print(f">>> {mne} <<<")
    print("="*80)
    
    mne_data = tactic.filter(F.col("MNE") == mne)
    
    if mne_data.count() == 0:
        print(f"    No data found for {mne}")
        continue
    
    # Overall range
    range_info = mne_data.agg(
        F.min("TREATMT_STRT_DT").alias("EARLIEST"),
        F.max("TREATMT_STRT_DT").alias("LATEST"),
        F.countDistinct("TREATMT_STRT_DT").alias("TOTAL_WAVES")
    ).collect()[0]
    
    print(f"\nDate Range: {range_info['EARLIEST']} to {range_info['LATEST']}")
    print(f"Total Waves: {range_info['TOTAL_WAVES']}")
    
    # Group by YEAR-MONTH to see distribution
    print(f"\nDeployments by Year-Month:")
    print("-"*60)
    
    monthly = mne_data.withColumn(
        "YEAR_MONTH", F.date_format(F.col("TREATMT_STRT_DT"), "yyyy-MM")
    ).groupBy("YEAR_MONTH").agg(
        F.countDistinct("TREATMT_STRT_DT").alias("WAVES_IN_MONTH"),
        F.count("*").alias("TOTAL_CLIENTS"),
        F.sum(F.when(F.col("TST_GRP_CD") == "TG4", 1).otherwise(0)).alias("TEST"),
        F.sum(F.when(F.col("TST_GRP_CD") != "TG4", 1).otherwise(0)).alias("CONTROL")
    ).orderBy("YEAR_MONTH")
    
    monthly.show(50, truncate=False)
    
    # Group by YEAR
    print(f"\nDeployments by Year:")
    print("-"*60)
    
    yearly = mne_data.withColumn(
        "YEAR", F.year(F.col("TREATMT_STRT_DT"))
    ).groupBy("YEAR").agg(
        F.countDistinct("TREATMT_STRT_DT").alias("WAVES_IN_YEAR"),
        F.count("*").alias("TOTAL_CLIENTS")
    ).orderBy("YEAR")
    
    yearly.show(truncate=False)

print("\n" + "="*80)
print("HYBRID AGGREGATION RECOMMENDATION")
print("="*80)
print("""
PROPOSED STRATEGY:
------------------
For campaigns with many waves, use time-based aggregation:

Option A - By recency:
  - OLD (> 6 months ago): Aggregate by QUARTER (e.g., "2024-Q3")
  - RECENT (last 6 months): Keep individual MONTH cohorts

Option B - By year:
  - 2024 data: Aggregate into single "2024" cohort
  - 2025 data: Keep monthly or individual waves

Option C - Rolling window:
  - Always show last N waves (e.g., last 12)
  - Ignore older data

Which approach do you prefer?
""")

print("="*80)
print("ANALYSIS COMPLETE")
print("="*80)
